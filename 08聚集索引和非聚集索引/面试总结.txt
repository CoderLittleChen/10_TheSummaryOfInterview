一、面试问题汇总
	1、多继承和多重继承的区别
	2、聚集索引和非聚集索引的区别
	3、int和int?的底层区别
	4、工作引擎审批流
	5、数据权限和功能权限的数据库底层设计
	6、数据库加索引的原则  是不是越多越好
	7、stringbuilder的底层原理
	8、mysql的分页查询  关键字  limit
	9、mysql  sqlserver怎样进行查询速度调优
	10、数据库设计的三范式
		    1)、第一范式：每一列属性都是不可再分的属性值，确保每一列的原子性，尽量合并属性相近或相似的列，不产生冗余数据。
			2)、第二范式：首先要符合第一范式，保证数据库中的每一列都和主键相关，而不能只与主键的某一部分相关。
								每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。
								例如一个人下多个订单，就会导致个人信息重复，需要将个人信息单独保存，然后将个人编号和订单编号关联。
			3)、第三范式：确保数据表中的每一列都和主键直接相关，而不能间接相关。
								比如在设计一个订单数据表的时候，可以将客户编号作为外键和订单表建立关联，而不可以添加客户的其他信息。
	11、restful设计原则  webapi  请求网站  无状态  怎样处理
	12、nginx的分发策略  
	13、foreach和for的效率谁高？switch和if的效率谁高？
	14、事务的四大特性   原子性   一致性   隔离性    持久性 
			原子性：事务包含的所有操作，要么全部成功，要么全部失败。成功必须要完全应用到数据库中，失败不能对数据库产生影响。
			一致性：事务执行前和执行后必须处于一直状态。例如用户A和用户B加起来一共是5000，无论AB之间如何相互转换，事务结束之后，
					   两个用户的钱加起来还是5000。
			隔离性：当多个用户并发访问数据库的时候，数据库为每一个用户开启的事务，不被其他事务所打扰，说个并发事务之间要相互隔离
					01、脏读   
							是指一个事务处理过程中读取了另一个未提交的事务中的数据，然后使用了这个数据。
					02、不可重复读
							不可重复读是指在一个事务内，多次读取同一个数据，在这个事务还没有结束，另一个事务也访问该同一数据，但是由于
							第二个事务的修改，那么第一个事务两次读取的数据可能不一样，因此称为不可重复读；即同一个事务中原始数据读取不可重复。
					03、幻读
							当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行修改，这种数据设计表中的全部数据行，同时，
							第二个事务也对这个表数据进行修改，这个修改是对表中新增/修改一条数据，那么操作第一个事务的用户发现表中的数据还没有
							修改的数据行，就好像发生了幻觉一样，这就是发生了幻读。
			持久性：一个事务一旦被提交了，那么对数据库的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事务的操作
			数据库提供的四种隔离级别：
			01、Read uncommitted(读未提交)  ：最低级别，任何情况都会发生
			02、Read Committed(读已提交)：可避免脏读的发生
			03、Reeartable read(可重复读)：可避免脏读  不可重复读的发生
			04、Serializable（串行化）：避免脏读 不可重复读  幻读的发生
				这四种隔离级别从上到下，隔离级别依次升高，MySql中默认隔离级别为03，Oracle  只支持04和02，默认是02
	15、使用存储过程的优点，比sql语句好在哪？	
			优点：
				1、对于简单的Sql语句，存储过程没有什么优势。对于复杂的业务逻辑，因为存储过程在创建的时候，数据库已经对其进行了一次解析和优化。
					存储过程一旦执行，内存中就会保留一份这个存储过程，这样下次在执行同样的存储过程时，可以从内存直接调用，执行速度比Sql快。
				2、可维护性：存储过程比程序更容易维护，这是因为可以实时更新DB端的存储过程。
				3、可扩展性：应用程序和数据操作分开，独立进行，而不是相互在一起，方便以后的扩展和DBA维护优化。
	16、CLR的作用
    17、如何判断值类型和引用类型    值类型继承自System.ValueType   引用类型继承自System.Object
		  值类型继承自ValueType  引用类型继承自Object,所有继承自System.ValueType的都是值类型
    18、抽象方法和虚方法的区别 
	19、抽象方法的类必须是抽象类吗？
	       类的几大设计原则  
				单一原则：一个类只负责一个功能领域中的相应职责
				开闭原则：一个软件实体应对扩展开放，对修改关闭   即软件实体应尽量在不修改原有代码的情况下进行扩展
				里氏转换原则：所有引用父类的地方必须能透明的使用其子类的对象
				依赖倒置原则：抽象不应该依赖于细节，细节应该依赖于抽象。要针对接口编程，而不是针对实现编程。 
				接口隔离原则：使用多个专门的接口，而不使用单一的总接口，每个接口应该承担一种独立的角色。    
				迪米特法则：
	20、托管资源和托管资源  finally 中执行dispose方法
		  using的实现原理
		  构造函数和静态构造函数的执行顺序
		  先执行构造函数还是先对变量赋值？   先对变量初始化赋值，然后执行构造函数
		  值类型和引用类型 方法中重新赋值，原变量是否会改变   
		  深拷贝和浅拷贝的原理
		  事务如何实现原子性  
		  .Net  Core

		  分布式
		  消息队列Rabbit
二、自身需要加强的几方面
	1、数据库调优   索引  sql语句执行速度优化
	2、网络安全  sql注入等怎样解决
	3、C#基础中常见问题点的底层区别  例如  int和int?的区别
	4、工作流  审批流   权限系统（功能权限 数据权限  具体数据库表该怎样设计）
	5、基础数据结构以及对应的算法实现以及对于时间复杂度和空间复杂度
	6、递归算法的时间复杂度  T[n]=aT[n/b]+f(n);   